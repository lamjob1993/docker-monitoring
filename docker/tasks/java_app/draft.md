В РАБОТЕ

**Шаг 7: Сборка приложения для запуска (JAR-файл)**

Для того чтобы упаковать наше приложение для запуска вне среды разработки (например, в Docker), мы соберем исполняемый JAR-файл. Spring Boot делает это удобным.

В терминале, находясь в корневой папке проекта `credit-pipeline`, выполните команду Maven Wrapper:
```bash
./mvnw clean package
```
* `clean`: Удаляет предыдущие результаты сборки (папку `target`).
* `package`: Компилирует код, запускает тесты (если есть) и упаковывает все в JAR-файл.

Maven выполнит сборку. В конце вы должны увидеть сообщение `BUILD SUCCESS`. Исполняемый JAR-файл будет создан внутри папки `target/`. Имя файла будет примерно таким: `credit-pipeline-1.0.0-SNAPSHOT.jar`. Этот один файл содержит все, что нужно для запуска приложения (кроме самой Java JVM).

---

**Шаг 8: Подготовка к Docker**

Теперь создадим файлы, которые расскажут Docker, как упаковать и запустить наше приложение.

1.  **Dockerfile:** Инструкции для сборки Docker образа.
    Создайте файл с именем `Dockerfile` (без расширения!) в корневой папке `credit-pipeline`.
    ```bash
    nano Dockerfile
    ```
    Вставьте следующий код:
    ```dockerfile
    # Используем официальный образ OpenJDK 21 (версия slim меньше)
    # Это означает, что в наш контейнер будет включена среда выполнения Java 21
    FROM openjdk:21-jdk-slim

    # Указываем, где находится собранный JAR-файл на вашей локальной машине
    # target/*.jar найдет любой файл с расширением .jar в папке target
    ARG JAR_FILE=target/*.jar

    # Копируем собранный JAR-файл из вашей локальной папки target/
    # внутрь Docker образа в корень и называем его app.jar
    COPY ${JAR_FILE} app.jar

    # Указываем Docker, что приложение внутри контейнера слушает порт 8080.
    # Это только информация/документация, не открывает порт наружу автоматически.
    EXPOSE 8080

    # Команда, которая будет выполнена при запуске контейнера.
    # Запускаем Java Virtual Machine и указываем ей запустить наш исполняемый JAR-файл app.jar
    ENTRYPOINT ["java", "-jar", "/app.jar"]
    ```
    Сохраните и закройте `Dockerfile`.

    **Как Java приложение запускается в контейнере:**
    * Строка `FROM openjdk:21-jdk-slim` добавляет в образ **операционную систему Linux** (минимальную, на базе Debian) **вместе с установленной OpenJDK 21**. То есть, JVM уже есть внутри образа.
    * Строка `COPY ${JAR_FILE} app.jar` копирует ваш собранный файл `credit-pipeline-1.0.0-SNAPSHOT.jar` (который вы создали командой `./mvnw clean package`) с вашего компьютера *внутрь* файловой системы создаваемого Docker образа, называя его `app.jar`.
    * Строка `ENTRYPOINT ["java", "-jar", "/app.jar"]` — это команда, которая выполнится, когда вы запустите контейнер на базе этого образа. Она запускает `java` (которая уже есть в образе) с параметром `-jar`, указывая путь к скопированному `app.jar`. Эта команда фактически запускает ваше Spring Boot приложение внутри контейнера.
    * Строка `EXPOSE 8080` просто документирует, что приложение внутри контейнера ожидает соединения на порту 8080. Сам по себе этот порт *не будет* доступен с вашего компьютера или из интернета без дополнительной настройки.

2.  **docker-compose.yml:** Описание сервисов (контейнеров) для запуска.
    Создайте файл с именем `docker-compose.yml` в корневой папке `credit-pipeline`.
    ```bash
    nano docker-compose.yml
    ```
    Вставьте следующий код:
    ```yaml
    # Версия синтаксиса файла Docker Compose
    version: '3.8'

    # Секция, где описываются наши сервисы (контейнеры)
    services:
      # Название нашего первого (и единственного) сервиса
      credit-pipeline-app:
        # Инструкция для Docker Compose: собрать образ для этого сервиса
        # на основе Dockerfile, который находится в текущей директории (.)
        build: .
        # Пробрасываем порты: ХОСТОВЫЙ_ПОРТ:ПОРТ_ВНУТРИ_КОНТЕЙНЕРА
        # Это делает порт 8080 внутри контейнера доступным на порту 8080 вашей хост-машины (вашего компьютера)
        ports:
          - "8080:8080"
        # Даем контейнеру понятное имя (опционально)
        container_name: simple-credit-pipeline
        # Настраиваем политику перезапуска: всегда пытаться перезапустить контейнер, если он остановился
        restart: always
    ```
    Сохраните и закройте `docker-compose.yml`.

    **Как Docker Compose запускает это:**
    * Когда вы выполните команду `docker compose up --build`, Docker Compose прочитает этот файл.
    * Он увидит сервис `credit-pipeline-app`.
    * Инструкция `build: .` скажет ему найти `Dockerfile` в текущей папке и использовать его для сборки Docker образа.
    * Инструкция `ports: "8080:8080"` скажет Docker, что нужно создать "мост" между портом 8080 на вашей хост-машине (вашем компьютере) и портом 8080 внутри контейнера, который будет запущен на базе собранного образа. Это позволяет вам обращаться к приложению внутри контейнера по адресу `localhost:8080`.
    * Затем Docker Compose запустит один контейнер на основе этого образа.

---

**Шаг 9: Сборка Docker образа и запуск контейнера**

Убедитесь, что Docker Engine запущен на вашей Ubuntu машине (обычно он запускается автоматически после установки и перезагрузки).

Откройте терминал и перейдите в корневую папку проекта `credit-pipeline`:
```bash
cd ~/projects/credit-pipeline
```

Выполните команду Docker Compose для сборки образа и запуска контейнера:
```bash
docker compose up --build -d
```
* `docker compose up`: Запустить сервисы, описанные в `docker-compose.yml`.
* `--build`: Собрать образ перед запуском (необходимо при первом запуске или после изменений в коде/Dockerfile).
* `-d`: Запустить контейнер в фоновом режиме (detached mode), чтобы терминал остался доступным.

Docker Compose сначала соберет образ (вы увидите вывод шагов из `Dockerfile`), затем создаст и запустит контейнер.

**Проверка статуса контейнера:**
Чтобы убедиться, что контейнер запущен, выполните:
```bash
docker ps
```
Вы должны увидеть строку с вашим контейнером `simple-credit-pipeline` (или другим именем, если вы его меняли) и статусом `Up ...`. Также будет видно проброс портов `0.0.0.0:8080->8080/tcp` (или `127.0.0.1:8080->8080/tcp`), что означает, что порт 8080 на вашем компьютере связан с портом 8080 в контейнере.

---

**Шаг 10: Проверка приложения в Docker**

Теперь, когда приложение работает внутри Docker-контейнера, вы можете обращаться к нему так же, как и при локальном запуске, потому что мы пробросили порт 8080.

* **Actuator метрики (из Docker):**
    * В браузере: `http://localhost:8080/actuator`
    * В браузере: `http://localhost:8080/actuator/health`
    * В терминале с `curl`:
        ```bash
        curl http://localhost:8080/actuator/metrics
        # Должен показать список метрик
        ```

* **Наше API (из Docker):**
    * В браузере: `http://localhost:8080/api/credit/info`
        ```json
        {"pipelineName":"SimpleCreditPipelineTemplate","version":"1.0.0","description":"Тестовый шаблон кредитного конвейера с Actuator и JSON API"}
        ```
    * В терминале с `curl` для POST запроса:
        ```bash
        curl -X POST http://localhost:8080/api/credit/apply \
        -H "Content-Type: application/json" \
        -d '{"clientId": "docker_test_client", "loanAmount": 50000}'
        ```
        Вы должны получить JSON ответ и увидеть логи в терминале контейнера. Чтобы посмотреть логи контейнера, выполните:
        ```bash
        docker logs simple-credit-pipeline
        ```

Приложение успешно запущено в Docker!

**Остановка контейнера:**
Когда закончите, остановите и удалите контейнер(ы) и сеть, созданные Docker Compose:
```bash
docker compose down
```

---

**Шаг 11: Подготовка к GitHub**

Чтобы удобно управлять версиями проекта и выложить его на GitHub, используйте Git. Убедитесь, что Git установлен (`sudo apt install git`, если нет).

Перейдите в корневую папку проекта `credit-pipeline` в терминале.

1.  **Инициализируйте Git репозиторий:**
    ```bash
    git init
    ```
    Это создаст скрытую папку `.git`, которая будет хранить историю изменений.

2.  **Проверьте `.gitignore`:** Файл `.gitignore`, созданный Spring Initializr, уже содержит правила для игнорирования результатов сборки (`target/`) и файлов IDE. Это важно.

3.  **Добавьте все файлы в отслеживание Git:**
    ```bash
    git add .
    ```
    Команда `.` добавляет все файлы и папки в текущей директории (кроме тех, что указаны в `.gitignore`) в список файлов, которые будут включены в следующий коммит.

4.  **Сделайте первый коммит (сохранение версии):**
    ```bash
    git commit -m "feat: Initial simple credit pipeline template with Actuator, API, and Docker"
    ```
    `git commit` сохраняет текущее состояние. `-m` добавляет сообщение, описывающее изменения.

5.  **Создайте репозиторий на GitHub:**
    * Зайдите на [github.com](https://github.com/) и войдите.
    * Нажмите кнопку "New repository" (или "+" в правом верхнем углу).
    * Выберите имя для репозитория, например, `simple-credit-pipeline-template`.
    * Оставьте его публичным или сделайте приватным.
    * **Важно:** НЕ ставьте галочки "Add a README file", "Add .gitignore", "Choose a license", так как у вас уже есть эти файлы локально.
    * Нажмите "Create repository".

6.  **Свяжите ваш локальный репозиторий с репозиторием на GitHub:**
    На странице созданного пустого репозитория на GitHub вы увидите инструкции. Скопируйте и выполните команды в вашем терминале, находясь в папке проекта. Они будут выглядеть примерно так:
    ```bash
    git remote add origin <URL_вашего_репозитория_на_github> # Замените на реальный URL
    git branch -M main # Переименовать ветку в main (стандартное имя)
    git push -u origin main # Отправить (запушить) коммиты из вашей ветки main на GitHub
    ```
    Пример URL: `https://github.com/Ваш_логин/simple-credit-pipeline-template.git`

После выполнения `git push`, ваш код появится на GitHub.

---

**Шаг 12: Итоговая структура проекта для GitHub**

На GitHub (и локально, за исключением игнорируемых файлов) структура вашего проекта будет выглядеть так:

```
simple-credit-pipeline-template/
├── .mvn
│   └── wrapper
│       ├── maven-wrapper.jar
│       └── maven-wrapper.properties
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com
│   │   │       └── example
│   │   │           └── creditpipeline
│   │   │               ├── CreditPipelineApplication.java
│   │   │               └── CreditController.java  # Наш файл с API
│   │   └── resources
│   │       └── application.properties # Наши настройки Actuator и порта
│   └── test
│       └── java
│           └── com
│               └── example
│                   └── creditpipeline
│                       └── CreditPipelineApplicationTests.java
├── .gitignore         # Правила для Git
├── mvnw               # Скрипт запуска Maven на Linux/macOS
├── mvnw.cmd           # Скрипт запуска Maven на Windows
├── pom.xml            # Описание проекта Maven
├── Dockerfile           # Инструкции для сборки Docker образа
└── docker-compose.yml   # Описание для запуска в Docker Compose
```
(Папка `target/` не будет добавлена в Git из-за правил в `.gitignore`).

---

Поздравляю! Вы полностью создали, настроили и упаковали в Docker простой шаблон Spring Boot приложения с Actuator метриками и JSON API, адаптированный для Ubuntu 22.04 с OpenJDK 17, и подготовили его для GitHub. У вас есть прочная база для дальнейшего развития вашего "кредитного конвейера" или любого другого микросервиса на Java. Успехов!
